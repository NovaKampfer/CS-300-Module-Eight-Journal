
##  CS 300 Module Eight Journal  
### Portfolio Submission — Data Structures and Algorithms  

**Student:** Matthew Baerg  
**Course:** CS 300 — Data Structures and Algorithms  
**Date:** 10/25/2025

---

###  Repository Contents  
- **Project One:** Runtime and memory analysis for vector, hash table, and tree data structures  
- **Project Two:** Working C++ program that reads, sorts, and prints course information in alphanumeric order  

---

###  Reflection  

**What was the problem you were solving in the projects for this course?**  
The main challenge in these projects was to design a program that could efficiently store, organize, and display computer science course data. The program needed to read data from a file, handle potential formatting issues, and output an alphanumeric list of courses. Additionally, I analyzed and compared the runtime and memory performance of different data structures to determine which was best suited for this task.

**How did you approach the problem?**  
I began by carefully reviewing the requirements and exploring several data structures—specifically a vector, a hash table, and a binary search tree. Understanding how each one stores and retrieves data helped me decide which structure to use for each operation. I relied on Big-O notation to estimate efficiency and focused on balancing readability and performance. Ultimately, this approach reinforced how vital it is to select the right data structure for scalability and speed.

**How did you overcome any roadblocks you encountered while going through the activities or project?**  
One of the biggest challenges was managing file-reading errors and ensuring that my data parsing was consistent with the file format. I overcame these by implementing error checks and testing with various input scenarios. When debugging complex logic (such as tree traversal), I used print statements and step-through debugging in my IDE to verify correct program flow.

**How has your work on this project expanded your approach to designing software and developing programs?**  
This project emphasized the importance of planning before coding. Writing pseudocode for each data structure allowed me to visualize the logic and runtime implications before implementing anything. It also taught me to think more critically about data flow and algorithmic efficiency, skills that directly transfer to larger-scale software design.

**How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?**  
I learned that clarity and organization are just as important as performance. By using modular functions, consistent naming conventions, and thorough comments, I made my code easier to update and debug later. The experience reinforced my commitment to writing clean, maintainable code that others can easily understand and extend—essential skills for collaborative development environments.

---

###  Summary  
These projects strengthened my understanding of how data structures directly impact program performance and maintainability. Through experimentation, debugging, and analysis, I not only developed more efficient solutions but also improved my overall approach to software design.
